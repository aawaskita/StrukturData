%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Vertical Line Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Peter Wilson (herries.press@earthlink.net)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page compiles as is. If you wish to include this title page in 
% another document, you will need to copy everything before 
% \begin{document} into the preamble of your document. The title page is
% then included using \titleGM within your document.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{report}

\usepackage{cite,graphicx}
\usepackage[chapter]{algorithm}
\usepackage{url,float}
\usepackage{hyperref}
\usepackage{uithesis}
\usepackage{listings}
\renewcommand{\bibname}{Daftar Referensi}
\renewcommand{\contentsname}{Daftar Isi}
\renewcommand{\listfigurename}{Daftar Gambar}
\renewcommand{\listtablename}{Daftar Tabel}
\renewcommand\lstlistingname{Program}
\renewcommand\lstlistlistingname{Daftar Program}
%\def\lstlistingautorefname{Program.}
\renewcommand{\chaptername}{BAB}
\renewcommand{\figurename}{\bo{Gambar}}
\renewcommand{\tablename}{\bo{Tabel}}
\include{hype.indonesia}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\newcommand*{\titleGM}{\begingroup % Create the command for including the title page in the document
\hbox{ % Horizontal box
\hspace*{0.2\textwidth} % Whitespace to the left of the title page
\rule{1pt}{\textheight} % Vertical line
\hspace*{0.05\textwidth} % Whitespace between the vertical line and title page text
\parbox[b]{0.75\textwidth}{ % Paragraph box which restricts text to less than the width of the page

{\noindent\Huge\bfseries Struktur Data }\\[2\baselineskip] % Title
{\large \textit{Diktat kuliah}}\\[4\baselineskip] % Tagline or further description
{\large \textsc{Dr. Arya Adhyaksa Waskita}} % Author name

\vspace{0.5\textheight} % Whitespace between the title block and the publisher
\begin{figure}[H]
\includegraphics[scale=.2]{pics/logo.png}
\end{figure}
STMIK Eresha - 2017

%{\noindent The Publisher \plogo}\\[\baselineskip] % Publisher and logo
}}
\endgroup}

%----------------------------------------------------------------------------------------
%	BLANK DOCUMENT
%----------------------------------------------------------------------------------------

\begin{document}

%\addChapter{\kataPengantar}


\pagestyle{empty} % Removes page numbers

\titleGM % This command includes the title page
\pagenumbering{roman}
\setcounter{page}{0}
\tableofcontents
\listoffigures
\lstlistoflistings
\include{pengantar}

\pagenumbering{arabic}
\chapter{Pendahuluan}
Memanfaatkan komputer dalam menyelesaikan suatu masalah menuntut pengetahuan tentang transformasi masalah tersebut agar dapat diselesaikan dengan komputer. Materi struktur data digunakan untuk memahami transfromasi data yang terlibat dalam suatu masalah serta operasi yang berlaku pada data sehingga dapat diselesaikan dengan komputer. Transformasi tersebut tentang bagaimana data diorganisasikan, dikendalikan serta struktur yang harus dirancang dan diterapkan. Targetnya adalah sebuah solusi yang sederhana dan efisien.

\section{Representasi data}
Dalam komputer, data dan instruksi dinyatakan dalam bentuk biner, berupa susunan angka $0$ dan $1$ dengan arti tertentu. Susunan 8 \texttt{bit} biner disebut dengan \texttt{byte} digunakan untuk merepresentasikan karakter. Sedangkan kumpulan karakter akan menjadi string. Ilustrasinya ditunjukkan pada Gambar \ref{fig:dataRep}.

\begin{figure}[H]
\centering
\includegraphics[scale=.45]{pics/dataRepresentation.png}
\caption{Representasi data dalam komputer}
\label{fig:dataRep}
\end{figure}

Acuan dalam merepresentasikan data ke dalam sistem biner antara adalah ASCII (\textit{American Standard Code for Information Interchange}) dan BCD (\textit{binary-coded decimal}). Dan setiap bahasa pemrograman telah mendefinisikan representasi untuk perintah dan data yang digunakannya seperti ilustrasi pada Gambar \ref{fig:dataRep}. Setiap jenis data memiliki skema representasi yang berbeda. Representasi data integer dilakukan menggunakan 8 bit (1 byte) biner. Misalnya, $27$ dinyatakan dalam bilangan biner sebagai $00011011$. Sementara untuk menyatakan bilangan negatifnya, dapat dilakukan dengan dua pendekatan. Yang pertama adalah melakukan operasi komplemen pada setiap bit biner, yaitu setiap bit $0$ diubah menjadi $1$, sedangkan bit $1$ menjadi $0$. Dengan demikian, angka $-27$ jika dinyatakan dalam biner dengan operasi komplemen menjadi $11100100$. Sedangkan representasi yang kedua adalah menambahkan angka $1$ pada hasil operasi komplemen pertama. Sehingga angka $-27$ dapat dinyatakan dalam bilangan biner dengan skenario kedua sebagai $11100101$.

Selan itu, bilangan desimal dapat juga dinyatakan dalam bilangan biner dengan terlebih dahulu memisahkan bagian bilangan bulat (mantissa) dengan bagian pangkat (eksponen)nya. Sebagai contoh, bilangan $209.52$ dapat dinyatakan sebagai $20952.10^{-2}$ dalam bilangan basis $10$. $20952$ adalah bagian mantissa, sedangkan $-2$ adalah bagian eksponennya. Dengan skenario sebelumnya, angka $20952$ dinyatakan dalam biner sebagai $101000111011$. Sedangkan bagian eksponennya dinyatakan dalam skenario komplemen sebagai $11111101$. Sehingga keduanya dapat digunakan untuk menyatakan bilangan $20952.10^{-2}$ sebagai $101000111011$.$11111101$.

\section{Tipe data abstrak}
Pada kondisi tertentu, kita tidak dapat (sulit) merepresentasikan data atau obyek ke dalam komputer. Pada kondisi tersebut, bukan saja data yang perlu disimpan, tetapi operasi matematika yang berlaku pada data tersebut. Datanyapun seringkali berupa data jamak dari tipe yang berbeda. Bahasa pemorgraman modern menyebut tipe data ini sebagai tipa data abstrak (ADT/\textit{Abstract Data Type}) yang muncul dalam bahasa pemrograman berorientasi obyek.

Untuk kasus yang lebih sederhana, di mana fokus utamanya justru pada sejumlah data yang perlu diacu bersama di saat yang sama, kita mengenal tipe data \texttt{structure}. Di sini, kita dapat mendefinisikan satu tipe data baru yang terdiri dari sejumlah tipe data yang telah didefinisikan dalam bahasa pemrograman yang kita gunakan. 

Terdapat dua istilah terkait tipe data ini. Selain data struktur yang merupakan data yang tersusun dari sejumlah elemen data, terdapat juga tipe struktur \textit{structured type}. \textit{Structure type} merupakan hubungan yang terdapat pada data (elemen). Jika data struktur fokus pada data dengan elemen lebih dari satu, \textit{structured type} fokus pada hubungan antar data.

Dapat disimpulkan bahwa ADT merupakan spesifikasi, sementara tipe data adalah penerapan dari ADT. ADT dapat juga dipandang sebagai merupakan bentuk umum dari tipe data. Jika telah didefinisikan dalam bahasa pemrograman tertentu sering disebut sebagai \textit{primitive data type}, sedangkan jika didefinisikan oleh pengguna disebut sebagai \textit{user defined data type}. Sementara data struktur adalah kumpulan data dengan tipe apapun. Hubungannya dapat diilustrasikan dalam Gambar \ref{fig:datatype} berikut.

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pics/datatype.png}
\caption{Hubungan tipe data}
\label{fig:datatype}
\end{figure} 

\section{Prinsip dasar pemrograman}
Prinsip dasar dalam pemrograman tahapan yang harus dilakukan dalam menyelesaikan masalah menggunakan bantuan komputer. Salah satu tahapan dalam pemrograman terstruktur dikenal sebagai \textit{system development life cycle} (SDLC). Tahapan SDLC adalah sebagai berikut.
\begin{enumerate}
\item Analisis masalah: apa yang menjadi masalah, apa saja solusinya, apa dan siapa (pemrograman berorientasi obyek) yang terlibat, tahapan dalam penyelelesaian, indikasi keberhasilan, dll.
\item Membuat \textit{prototype}, umunya dilakukan dalam bentuk \textit{pseduo code} atau diagram alir.
\item Membangun algoritma:
\begin{itemize}
\item merancang \label{sec:rancangan}
\item verifikasi
\item analisis
\item memprogram
\begin{itemize}
\item menguji
\item evaluasi
\item perbaikan (jika perlu)
\item optimasi
\end{itemize}
\item Merawat
\end{itemize}
\end{enumerate}

Dalam merancang algoritma (termasuk juga program yang menerapkan algoritma) seperti disebutkan dalam tahapan ke-\ref{sec:rancangan} dari SDLC, diperlukan tahapan berikut.
\begin{enumerate}
\item Program harus sejalan dengan masalah yang dihadapi, apakah itu prosedur, data maupun struktur datanya.
\item Bekerja baik pada semua kondisi di mana masalah terjadi. Jika ada kondisi di mana solusi yang digunakan tidak dapat mencapai hasil yang diinginkan, kondisi tersebut menjadi pengecualian dan harus disebutkan secara eksplisit.
\item Dokumentasi tentang bagaimana rancangan tersebut dihasilkan (dokumentasi rancangan)
\item Tersusun atas sejumlah modul, fungsi, subrutin. Modularisasi menjadi penting ketika algoritma yang dibangun komplek dan besar. Modularisasi akan memberikan keuntungan dari kemudahan pengembangan.
\item Waktu eksekusi dan ruang penyimpanan yang diperlukan. Kedua hal ini adalah kriteria sebuah algoritma disebut baik. Kebutuhan media penyimpanan yang dimaksud di sini meliputi media yang bersifat \textit{volatile} (\textit{Random Access Memory}/RAM) atau \textit{non-volatile} (\textit{hard disk}). Sementara waktu eksekusi tentu akan berbeda ketika dijalankan di mesin yang berbeda, sehingga ukuran tepatnya adalah jumlah operasi aritmatika dan logika yang dijalankan sebuah algoritma. Nilainya dinotasikan sebagai $\Theta$ atau \textbf{O}. Nilai notasi $\Theta$ untuk beragam struktur data dan algoritmanya diilustasikan pada Gambar \ref{fig:bigOh}\footnote{\url{http://bigocheatsheet.com/}}.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.45]{../CommonDS.png}
\caption{Perbandingan nilai $\Theta$ sejumlah struktur data dan algoritma}
\label{fig:bigOh}
\end{figure}

Algoritma yang dirancang selanjutnya dianalisis kinerjanya dalam bentuk waktu eksekusi. Selain dipengaruhi oleh mesin di mana algoritma dijalankan, waktu eksekusi juga dipengaruhi oleh masukannya. Sebagai ilustrasi, mengurutkan sejumlah nilai yang telah terurut sebelumnya tentu membutuhkan waktu yang lebih singkat dibanding dengan nilai-nilai yang belum terurut. Waktu eksekusi yang dipengaruhi masukan dapat dikelompokkan dalam 3 kategori.
\begin{enumerate}
\item \textit{Best}: waktu minimum yang diperlukan sebuah algoritma.
\item \textit{Average}: waktu rerata dari eksekusi sebuah algoritma dalam menyelesaikan masalah yang sama dengan masukan yang berbeda. Jika satu masalah memiliki kemungkinan masukan sebanyak $n$, maka waktu rerata adalah rata-rata dari waktu untuk menyelesaikan masalah dengan $n$ masukan tersebut. Jika waktu untuk menyelesaikan algoritma untuk satu jenis masukan adalah $T_i$, maka waktu rerata ($T_{avg}$) dapat diformulasikan dalam persamaan (\ref{eq:tavg}).
\item \textit{Worst}: waktu terburuk sebuah algoritma dalam mengolah satu jenis masukan. 
\end{enumerate}

\begin{equation}
T_{avg}=\frac{\sum_{i=1}^{n}T_i}{n}
\label{eq:tavg}
\end{equation}

Algoritma sendiri dapat didefinisikan sebagai urutan instruksi yang harus diikuti untuk menyelesaikan suatu masalah. Atau dapat juga didefinisikan sebagai prosedur untuk mengubah \textit{input} menjadi \textit{output}. Karakteristik algoritma yang baik adalah sebagai berikut.
\begin{enumerate}
\item Setiap instruksi di dalamnya harus unik dan tepat.
\item Setiap instruksi tidak boleh dijalankan secara berulang tanpa batas.
\item Perulangan tugas yang sama harus dihindari
\item Harus memberikan hasil yang tepat untuk masalah yang dihadapi
\item Efisien dalam menyelesaikan masalah. Faktor efisiensi seperti yang telah disebutkan terdiri dari efisiensi terkait media penyimpanan dan waktu eksekusi.
\end{enumerate} 

\chapter{Bahasa Pemrograman C++}
\section{Pendahuluan}
Bahasa pemrograman \texttt{C++} dipilih dalam diktat ini karena \texttt{C++} secara eksplisit memanfaatkan \textit{pointer} sebagai sarana membangun beragam struktur data. Sementara bahasa pemrograman lain yang lebih modern telah mengemas hal tersebut ke dalam class. Sebagai bahan ajar, \texttt{C++} dinilai lebih mampu memberikan pemahaman tentang merancang dan menerapkan rancangan struktur data ketimbang hanya menggunakan class yang telah terdefinisi dengan baik. Program \ref{hellocpp} memperlihatkan program sederhana \texttt{C++}.

\scriptsize
\begin{lstlisting}[language=c++, numbers=left, numberstyle=\tiny, caption=hello.cpp, showstringspaces=false, label=hellocpp]
#include <iostream>
using namespace std;

int main() {
  cout << "Hello world\n";
  return 0;
}
\end{lstlisting}
\normalsize

Penjelasannya adalah sebagai berikut.
\begin{enumerate}
\item Baris ke-1, merupakan pemanggilan pustaka di mana fungsi-fungsi yang digunakan dalam program diletakkan. Dalam contoh Program \ref{hellocpp}, digunakan fungsi \texttt{cout} yang digunakan untuk menampilkan data ke \textit{standard output} (layar) dan fungsi tersebut didefinisikan di pustaka \texttt{iostream}.
\item Baris ke-2, digunakan untuk menyederhanakan penulisan fungsi. Karena \texttt{C++} adalah bahasa pemrograman berorientasi obyek, setiap fungsi tentu terdefinisi di dalam class tertentu, sehingga pemanggilan terhadap fungsi \texttt{cout} dilakukan apa adanya. Sebaliknya, tanpa deklarasi ini pemanggilan fungsi \texttt{cout} harus dilakukan dengan cara \texttt{std::cout}.
\item Baris ke-4, setiap program berbasis \texttt{C/C++} akan dieksekusi dari fugnsi yang bernama \texttt{main}. Tanpa fungsi ini, program \texttt{C/C++} tidak dapat dieksekusi (proses kompilasi tidak dapat menghasilkan \textit{executable file}).
\item Baris ke-5, digunakan untuk menampilkan teks berupa "Hello World" ke layar.
\item Baris ke-6, digunakan untuk memenuhi syarat berupa \textit{return value} dari fungsi main (Baris ke-4). Biasanya, fungsi yang mengembalikan nilai $0$ disepakati sebagai fungsi yang menjalankan tugas dengan baik. Jika tidak ingin melakukan pengembalian fungsi, maka fungsi \texttt{main} harus diberi tanda \textit{return value} sebagai \texttt{void}.
\item Setiap fungsi dalam \texttt{C/C++} dimulai oleh karakter "\{" dan diakhiri oleh karakter "\}", dan setiap instruksi di akhiri dengan karakter ";".
\item Di terminal, jalankan perintah \texttt{g++ -o hello hello.cpp}, dengan penjelasan.
\begin{itemize}
\item \texttt{g++}: memanggil aplikasi kompilator \texttt{C++}
\item \texttt{-o}: opsi untuk melakukan kompilasi dan \textit{linking} (meski dalam konteks Program \ref{hellocpp} tidak diperlukan) sehingga dihasilkan \textit{executable file}.
\item \texttt{hello}: nama executable file, jika dijalankan di Microsoft Windows dengan bantuan aplikasi MinGW, secara otomatis ditambahkan ekstensi \texttt{.exe}.
\item \texttt{hello.cpp}: kode sumber yang akan dikompilasi
\end{itemize}
\end{enumerate}

\section{IDE}
IDE (\textit{Integrated Development Environment}) adalah aplikasi yang digunakan dalam mengembangkan program. Untuk tujuan mempelajari materi struktur data, sebenarnya nyaris tidak diperlukan IDE. Kita hanya perlu memiliki kompilator \textit{C++} sebagai bahasa pemrograman yang memiliki notasi eksplisit terkait \textit{pointer} (dijelaskan dalam sub bab \ref{sec:pointer}) serta editor teks untuk menulis sejumlah instruksi \texttt{C++}. Untuk pengguna sistem operasi GNU/Linux dalam berbagai variannya, nyaris semua jenis kompilator tersedia secara gratis. Saya sendiri menggunakan editor teks Geany\footnote{\url{https://www.geany.org/}} dengan kompilator \texttt{C++} dari GNU \textit{Project}.

Namun, tidak demikian halnya dengan pengguna sistem Operasi Microsoft Windows. Umumnya, aplikasi di sistem operasi ini dikemas secara terintegrasi, bahkan dengan asumsi kita sedang berhadapan dengan sebuah proyek besar yang butuh cara mengelola proyek (dalam hal ini \textit{software}) yang mumpuni. Padahal, di sisi lain, kita hanya memerlukan editor teks tempat di mana kita menyusun program serta kompilator yang akan membuat program tersebut dapat dijalankan. Beruntung, ada sejumlah aplikasi yang dapat memberikan kita lingkungan pengembangan yang sederhana seperti halnya di sistem operasi GNU/Linux. Misalnya dengan aplikasi MinGW (Minimalist GNU for Windows)\footnote{\url{http://www.mingw.org/}} atau Cygwin\footnote{\url{https://www.cygwin.com/}}. Jangan lupa untuk memasang kompilator \texttt{C++} pada keduanya. Untuk yang masih kesulitan menggunakan aplikasi berbasis perintah baris seperti pada MinGW dan Cygwin, dapat menggunakan aplikasi IDE yang canggih seperti Visual Studio atau NetBeans dengan \textit{plugin} kompilator \texttt{C/C++}.

\section{Tipe data \texttt{pointer} dan \texttt{struct}}
\label{sec:pointer}
Tipe data \textit{pointer} adalah salah satu tipe data yang didefinisikan di \texttt{C/C++}. Tugasnya untuk menunjuk lokasi memori yang menjadi perhatian. Tipe data ini, tidak untuk menyimpan nilai suatu variabel tetapi alamat memori secara fisik di mana suatu nilai disimpan. Meskipun hanya bertugas menunjuk, tetapi tipe datanya harus disesuaikan dengan nilai yang akan ditunjuk. 

Sebagai contoh, untuk mendefinisikan sebuah variabel \textit{integer}, \texttt{C/C++} memiliki sintaks \texttt{int a;}. Untuk membuat sebuah tipe data \textit{pointer} yang akan menunjuk variabel bertipe \textit{integer}, \texttt{C/C++} memiliki sintaks \texttt{int *p;}. Sedangkan untuk membuat \textit{pointer} \texttt{p} menunjuk variabel \texttt{a}, \texttt{C/C++} memilki sintaks \texttt{p=\&a;}. Proses \textit{assignment} tersebut juga dapat dilakukan sekaligus pada saat deklarasi dengan sintaks \texttt{int *p=\&a;}. Intinya, tipe data \textit{pointer} dicirikan dengan karakter "\texttt{*}" di awal variabel dan mengikuti variabel yang ditunjuk. Jika akan digunakan menunjuk vairabel \textit{integer}, maka \textit{pointer} juga harus dideklarasikan sebagai \textit{integer}.

Kemudian, ada tipe data lainnya yang bertugas untuk mengemas sejumlah tipe data yang telah terdefinisi dalam \texttt{C/C++} yang disebut sebagai \texttt{struct}. Tipe data ini memungkinkan kita membuat tipe data baru yang mirip dengan sebuah obyek tanpa fungsi, karena hanya memiliki atribut. Sekali diacu dalam program, maka kita dapat mengakses semua data yang dikemas dalam \texttt{struct}. Program \ref{pointerstruct} mengilustrasikan penggunaan variabel \texttt{pointer} dan \texttt{struct}.

\scriptsize
\begin{lstlisting}[language=c++, numbers=left, numberstyle=\tiny, caption=intro.cpp, showstringspaces=false, label=pointerstruct]
#include <iostream>
using namespace std;

typedef struct data {
	int nilai;
	struct data *pointer;
}DATA;

int main() {
	int a;
	a=10;
	int *p;
	p=&a;
	DATA x;
	x.nilai=7;
	x.pointer=NULL;
	
	cout << "Nilai variabel a adalah " << a << " dan berlokasi di alamat " << &a << endl;
	cout << "Nilai variabel *p adalah " << *p << " dan berlokasi di alamat " << p << endl;
	cout << "x.nilai=" << x.nilai << ", x.pointer merujuk ke alamat " << x.pointer << endl;
	return 0;
}
\end{lstlisting}
\normalsize

Penjelasannya adalah sebagai berikut.
\begin{enumerate}
\item Baris ke-4 s/d 7: definisi tipe data baru berupa \texttt{struct data}. Pernyataan \texttt{typedef} di depannya menunjukkan bahwa tipe data \texttt{struct data} memiliki nama alias \texttt{DATA}. Itu sebabnya di baris ke-4 tertulis \texttt{DATA} yang berarti nama alias untuk \texttt{struct data}.
\begin{itemize}
\item Baris ke-5: definisi penyusun pertama \texttt{struct data}, yaitu \texttt{int nilai;}.
\item Baris ke-6: definisi penyusun kedua \texttt{struct data}, yaitu \texttt{struct data *pointer;}. Karena penyusun kedua ini ditugaskan untuk menujukan variabel dengan tipe \texttt{struct data}, maka ia harus didefinisikan dengan tipe yang sama.
\end{itemize}
\item Baris ke-10 dan 11: deklarasi dan \textit{assignment} variabel \textit{integer} dengan nama \texttt{a} dan dengan nilai \texttt{10}.
\item Baris ke-12 dan 13: deklarasi dan \textit{assignment} variabel \texttt{pointer} dengan nama \texttt{*p} dan bernilai \texttt{\&a} (alamat dari variabel \texttt{a} yang disimpan di RAM). 
\item Baris ke-14: deklarasi variabel \texttt{DATA} dengan nama \texttt{x}. Perhatikan kembali cara mendeklarasi variabel di baris ke-10 dan 12.
\item Baris ke-15 dan 16: \textit{assignment} nilai elemen penyusun variabel \texttt{x}, yaitu
\begin{itemize}
\item \texttt{x.nilai=7}
\item \texttt{x.pointer=NULL}: \texttt{pointer} belum menunjuk ke variabel apapun yang bertipe \texttt{DATA}.
\end{itemize}
\item Baris ke-18 s/d 20: menuliskan nilai-nilai yang sebelumnya di-\textit{assign} ke variabel untuk ditampilkan di layar.
\item Baris tanpa penjelasan memiliki penjelasan yang sama dengan penjelasan Program \ref{hellocpp}.
\end{enumerate}

\bibliographystyle{apalike}
\bibliography{reference}
\end{document}
